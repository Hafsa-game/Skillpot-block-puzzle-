<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Block Puzzle (SkillPot)</title>
<style>
  body{font-family:Arial,Helvetica,sans-serif;text-align:center;background:#111;color:#fff;margin:0;padding:20px}
  h1{color:#E50914;margin-bottom:6px}
  #info{margin-bottom:10px}
  #grid{display:grid;grid-template-columns:repeat(3,100px);grid-gap:6px;justify-content:center;margin:0 auto 12px}
  .tile{width:100px;height:100px;background:#E50914;display:flex;align-items:center;justify-content:center;font-size:28px;border-radius:8px;cursor:pointer}
  .blank{background:#444;cursor:default}
  #controls{margin-top:6px}
  #status{margin-top:12px}
  button{padding:8px 12px;border-radius:6px;border:none;background:#E50914;color:#fff;font-weight:700}
</style>
</head>
<body>
  <h1>Block Puzzle</h1>
  <div id="info">
    <span id="timer">Time: 0s</span> Â· <span id="moves">Moves: 0</span>
  </div>
  <div id="grid"></div>
  <div id="controls">
    <button id="reshuffle">Reshuffle</button>
    <button id="giveup">Give Up</button>
  </div>
  <div id="status"></div>

<script>
/* --------- helpers to read URL params passed from Thunkable --------- */
function getQueryVar(key){
  const q = location.search.substring(1).split("&");
  for(let i=0;i<q.length;i++){
    const p = q[i].split("=");
    if(decodeURIComponent(p[0])===key) return decodeURIComponent(p[1]||"");
  }
  return "";
}

/* inputs from Thunkable */
const matchId = getQueryVar("match_id") || "MISSING_MATCH";
const playerEmail = getQueryVar("email") || "unknown@example.com";

/* game state */
let tiles = [1,2,3,4,5,6,7,8,""]; // 9th is blank
let blankIndex = 8; // index in array (0-based) of blank
let moves = 0;
let elapsed = 0;
let running = false;
let intervalId = null;
const TIME_LIMIT = 120; // seconds (2 minutes)

/* DOM */
const grid = document.getElementById("grid");
const timerLabel = document.getElementById("timer");
const movesLabel = document.getElementById("moves");
const status = document.getElementById("status");
const reshuffleBtn = document.getElementById("reshuffle");
const giveupBtn = document.getElementById("giveup");

/* render function */
function render(){
  grid.innerHTML = "";
  tiles.forEach((t,i)=>{
    const d = document.createElement("div");
    d.className = "tile";
    if(t === "") { d.classList.add("blank"); d.innerText = ""; }
    else d.innerText = t;
    d.addEventListener("click", ()=>tileClick(i));
    grid.appendChild(d);
  });
}

/* neighbors for index (0-based 3x3) */
function neighbors(index){
  const nbr = [];
  const row = Math.floor(index/3);
  const col = index%3;
  if(col>0) nbr.push(index-1);
  if(col<2) nbr.push(index+1);
  if(row>0) nbr.push(index-3);
  if(row<2) nbr.push(index+3);
  return nbr;
}

/* swap helper */
function swap(i,j){
  const tmp = tiles[i];
  tiles[i] = tiles[j];
  tiles[j] = tmp;
}

/* shuffle by doing legal moves from solved state => guarantees solvable */
function shuffle(times=200){
  tiles = [1,2,3,4,5,6,7,8,""];
  blankIndex = 8;
  for(let k=0;k<times;k++){
    const nbr = neighbors(blankIndex);
    const choice = nbr[Math.floor(Math.random()*nbr.length)];
    swap(blankIndex, choice);
    blankIndex = choice;
  }
  moves = 0;
  elapsed = 0;
  running = false;
  stopTimer();
  updateHUD();
  render();
  status.innerText = "Good luck!";
}

/* start & stop timer */
function startTimer(){
  if(running) return;
  running = true;
  intervalId = setInterval(()=>{
    elapsed++;
    updateHUD();
    if(elapsed >= TIME_LIMIT){
      // time's up
      stopTimer();
      finalize(false); // false = not solved
    }
  }, 1000);
}
function stopTimer(){
  running = false;
  if(intervalId){ clearInterval(intervalId); intervalId = null; }
}

/* update HUD */
function updateHUD(){
  timerLabel.innerText = "Time: " + elapsed + "s";
  movesLabel.innerText = "Moves: " + moves;
}

/* when a tile is clicked */
function tileClick(i){
  const blank = tiles.indexOf("");
  const possible = neighbors(i);
  if(possible.includes(blank)){
    // legal move
    swap(i, blank);
    blankIndex = i; // new blank position
    moves++;
    if(!running) startTimer(); // start on first legal move
    updateHUD();
    render();
    if(isSolved()){
      stopTimer();
      finalize(true);
    }
  }
}

/* check solved */
function isSolved(){
  for(let i=0;i<8;i++){
    if(tiles[i] !== i+1) return false;
  }
  // tiles[8] should be blank
  return tiles[8] === "";
}

/* finalize & send result to Thunkable parent */
function finalize(solved){
  stopTimer();
  const result = {
    type: "PUZZLE_DONE",
    match_id: matchId,
    email: playerEmail,
    solved: solved ? 1 : 0,
    time_seconds: solved ? elapsed : elapsed, // if not solved we still post time
    moves: moves,
    timestamp: new Date().toISOString()
  };
  status.innerText = solved ? "Solved! Sending result..." : "Time up or given up. Sending result...";
  // send JSON string to parent (Thunkable WebViewer will receive this)
  try{
    window.parent.postMessage(JSON.stringify(result), "*");
  }catch(e){
    // fallback: show the JSON so user can screenshot
    status.innerText = "Result: " + JSON.stringify(result);
  }
}

/* buttons */
reshuffleBtn.addEventListener("click", ()=>shuffle(200));
giveupBtn.addEventListener("click", ()=>{
  finalize(false);
});

/* init */
shuffle(200);
render();
updateHUD();
</script>
</body>
</html>

